(function registerIlBronzaDatatablesColumnVisibility() {
	if ($.fn.dataTable && $.fn.dataTable.Api) {

		function ibDescribeNodeChain(node) {
			if (!node || !node.tagName) return '';

			const tag = node.tagName.toLowerCase();
			const children = Array.from(node.children || []).filter(c => c && c.tagName);

			if (!children.length) return tag;

			// a (span + i) -> "a span + i"
			const described = children.map(ibDescribeNodeChain).filter(Boolean);
			return tag + ' ' + described.join(' + ');
		}

		function ibGetTdStructureSignature(td) {
			if (!td) return 'td';

			const children = Array.from(td.children || []).filter(c => c && c.tagName);
			if (!children.length) return 'td';

			// root branches prefixed with "td " like the examples:
			// td has <a><i/></a> and <a><span/></a> -> "td a i + td a span"
			return children
				.map(c => {
					const chain = ibDescribeNodeChain(c);
					return chain ? ('td ' + chain) : 'td';
				})
				.filter(Boolean)
				.join(' + ');
		}

		function ibCollectDistinctTagClassSignatures(td)
		{
			const out = new Set();
			if (! td)
				return out;

			// Collect elements + compute per-tag intersection of classes ("base" classes)
			// Base classes are removed ONLY if there is real variation (more than one distinct class-combination)
			const elements = Array.from(td.querySelectorAll('*'));
			const byTagBase = {};   // tag -> Set of classes present on ALL elements of that tag
			const byTagCombos = {}; // tag -> Set of distinct class-combinations (serialized)
			const collected = [];   // [{tag, classes:Set}]

			elements.forEach(function (el) {
				if (! el || ! el.tagName)
					return;

				const tag = el.tagName.toLowerCase();
				if (! el.classList || ! el.classList.length)
					return;

				const clsSet = new Set();
				el.classList.forEach(function (c) {
					if (c)
						clsSet.add(c);
				});

				if (! clsSet.size)
					return;

				collected.push({ tag: tag, classes: clsSet });

				// Track distinct class-combinations for this tag
				if (! byTagCombos[tag])
					byTagCombos[tag] = new Set();

				const comboKey = Array.from(clsSet).sort().join('|');
				byTagCombos[tag].add(comboKey);

				// Build intersection with existing base set
				if (! byTagBase[tag])
				{
					byTagBase[tag] = new Set(clsSet);
				}
				else
				{
					const next = new Set();
					byTagBase[tag].forEach(function (c) {
						if (clsSet.has(c))
							next.add(c);
					});
					byTagBase[tag] = next;
				}
			});

			// Build signatures, excluding base classes only when there is real variation for that tag
			collected.forEach(function (row) {
				const tag = row.tag;
				const comboCount = (byTagCombos[tag] && byTagCombos[tag].size) ? byTagCombos[tag].size : 0;
				const base = comboCount > 1 ? (byTagBase[tag] || new Set()) : new Set();

				row.classes.forEach(function (cls) {
					if (! cls)
						return;
					if (String(cls).indexOf(' ') !== -1)
						return;

					// Skip base classes that are always present for this tag (e.g. fa-solid) ONLY if there is variation
					if (base.has(cls))
						return;

					out.add('td ' + tag + '.' + cls);
				});
			});

			return out;
		}

		function ibCollectDistinctTagClassSignaturesFromTds(tds)
		{
			const out = new Set();
			if (! tds || ! tds.length)
				return out;

			// Collect over ALL td nodes (column scope)
			const byTagBase = {};   // tag -> Set of classes present on ALL elements of that tag (intersection)
			const byTagCombos = {}; // tag -> Set of distinct class-combinations (serialized)
			const collected = [];   // [{tag, classes:Set}]

			Array.from(tds).forEach(function (td) {
				if (! td)
					return;

				const elements = Array.from(td.querySelectorAll('*'));
				elements.forEach(function (el) {
					if (! el || ! el.tagName)
						return;

					const tag = el.tagName.toLowerCase();
					if (! el.classList || ! el.classList.length)
						return;

					const clsSet = new Set();
					el.classList.forEach(function (c) {
						if (c)
							clsSet.add(c);
					});

					if (! clsSet.size)
						return;

					collected.push({ tag: tag, classes: clsSet });

					// combos
					if (! byTagCombos[tag])
						byTagCombos[tag] = new Set();
					const comboKey = Array.from(clsSet).sort().join('|');
					byTagCombos[tag].add(comboKey);

					// intersection
					if (! byTagBase[tag])
						byTagBase[tag] = new Set(clsSet);
					else
					{
						const next = new Set();
						byTagBase[tag].forEach(function (c) {
							if (clsSet.has(c))
								next.add(c);
						});
						byTagBase[tag] = next;
					}
				});
			});

			// Emit signatures: exclude base classes only when there is variation for that tag
			collected.forEach(function (row) {
				const tag = row.tag;
				const comboCount = (byTagCombos[tag] && byTagCombos[tag].size) ? byTagCombos[tag].size : 0;
				const base = comboCount > 1 ? (byTagBase[tag] || new Set()) : new Set();

				row.classes.forEach(function (cls) {
					if (! cls)
						return;
					if (String(cls).indexOf(' ') !== -1)
						return;
					if (base.has(cls))
						return;

					out.add('td ' + tag + '.' + cls);
				});
			});

			return out;
		}

		function ibMergeStructuresAndClassSelectors(structures, classSelectors)
		{
			const set = new Set();
			(structures || []).forEach(function (s) { if (s) set.add(s); });
			(classSelectors || []).forEach(function (s) { if (s) set.add(s); });
			return Array.from(set).sort(function (a, b) { return a.localeCompare(b); });
		}

		function ibInspectVisibleColumnStructures(dt, columnIndex) {
			if (!dt || typeof dt.column !== 'function') return;

			const nodes = dt.column(columnIndex, { page: 'current' }).nodes();
			const set = new Set();

			const classSet = new Set();

			for (let i = 0; i < nodes.length; i++) {
				const td = nodes[i];
				set.add(ibGetTdStructureSignature(td));
			}

			const tagClass = ibCollectDistinctTagClassSignaturesFromTds(nodes);
			tagClass.forEach(function (sig) { classSet.add(sig); });

			const structures = Array.from(set);
			const classSelectors = Array.from(classSet);
			const merged = ibMergeStructuresAndClassSelectors(structures, classSelectors);

			console.log(merged);
			return merged;
		}

		function clearPreviewFromColumn(dt, columnIndex)
		{
			if (! dt)
				return;

			const nodes = dt.column(columnIndex, { page: 'current' }).nodes();
			if (! nodes || ! nodes.length)
				return;

			const clearKeys = [
				'fontStyle',
				'fontSize',
				'letterSpacing',
				'fontWeight',
				'textDecoration',
				'textAlign',
				'color',
				'backgroundColor',
				'width',
				'minWidth',
				'maxWidth',
			];

			$(nodes).each(function () {
				const td = this;

				// clear TD
				clearKeys.forEach(function (k) {
					td.style[k] = '';
				});

				// clear descendants
				$(td).find('*').each(function () {
					const el = this;
					clearKeys.forEach(function (k) {
						el.style[k] = '';
					});
				});
			});
		}

		$.fn.dataTable.Api.register('manageColumnVisibility()', function (columnName, visibility)
		{
			let dt = this;

			let table = this.getTableElement();
			let tableColumnDisplayRoute = table.data('columndisplayroute');

			let a = $('#togglefields' + table.attr('id')).find('[data-name="' + columnName + '"]');

			let action;

			if(visibility)
				action = 'showColumn';
			else
				action = 'hideColumn';

			var column = dt.column(a.data('column'));

			column.visible( visibility );

			if(visibility)
				$(a).data('visibility', 1).addClass('uk-text-bold');
			else
				$(a).data('visibility', 0).removeClass('uk-text-bold');

			$.ajax({
				url: tableColumnDisplayRoute,
				dataType: 'json',
				type: 'POST',
				data: {
					columnName: columnName,
					action: action
				},
				success: function(response)
				{
					if(! response.success == true)
						return this.error(response);

					if(visibility)
						window.addSuccessNotification('Colonna "' + a.text() + '" mostrata con successo');
					else
						window.addWarningNotification('Colonna "' + a.text() + '" nascosta con successo');

				},
				error: function (response)
				{
					window.addDangerNotification('Impossibile modificare la visualizzazione della colonna');
				}
			});
		});



		$(document).ready(function($)
		{
			$('a.toggle-vis').on('click', function (e)
			{
				var that = this;
				e.preventDefault();

				var dt = $('#' + $(that).parents('ul.toggle-vis-container').data('tableid')).DataTable();

				let columnName = $(that).data('name');
				let currentVisibility = $(that).data('visibility');

				return dt.manageColumnVisibility(columnName, ! currentVisibility);
			});

			// Column settings preview (styles) - selects column via gear and applies styles to real TDs
			if (! window.__ibColumnSettingsPreviewBound)
			{
				window.__ibColumnSettingsPreviewBound = true;

				window.columnIndexPreview = window.columnIndexPreview ?? 6;
				window.__ibColumnStyleDraftBySelector = window.__ibColumnStyleDraftBySelector || {};
				window.__ibColumnStyleDraft = window.__ibColumnStyleDraft || {}; // legacy (kept, but unused)
				window.__ibColumnNamePreview = null;

				function normalizeCssValue(style, value)
				{
					if (value === undefined || value === null)
						return value;

					// numeric inputs: treat as px for numeric-only styles
					const isNumeric = (typeof value === 'number') || (typeof value === 'string' && value !== '' && !isNaN(value));

					if (style === 'fontSize' || style === 'letterSpacing')
						return isNumeric ? (value + 'px') : value;

					// width/minWidth/maxWidth can be px (number), %, auto, etc.
					if (style === 'width' || style === 'minWidth' || style === 'maxWidth')
					{
						if (value === '' || value === 'auto')
							return value;
						return isNumeric ? (value + 'px') : value;
					}

					return value;
				}

				function getDtFromToggleContainer(el)
				{
					const tableId = $(el).parents('ul.toggle-vis-container').data('tableid');
					if (! tableId)
						return null;

					return $('#' + tableId).DataTable();
				}

				function parsePx(value)
				{
					if (! value || value === 'normal')
						return 0;
					if (typeof value === 'string' && value.endsWith('px'))
						return parseFloat(value.replace('px', ''));
					return parseFloat(value) || 0;
				}

				function rgbToHex(rgb)
				{
					if (! rgb)
						return '';
					const m = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
					if (! m)
						return '';
					return '#'
						+ ('0' + parseInt(m[1], 10).toString(16)).slice(-2)
						+ ('0' + parseInt(m[2], 10).toString(16)).slice(-2)
						+ ('0' + parseInt(m[3], 10).toString(16)).slice(-2);
				}

				function mostCommon(values)
				{
					const map = {};
					let max = 0;
					let res = null;
					values.forEach(function (v) {
						if (v === undefined || v === null)
							return;
						map[v] = (map[v] || 0) + 1;
						if (map[v] > max)
						{
							max = map[v];
							res = v;
						}
					});
					return res;
				}

				function signatureToCssSelectors(signature)
				{
					if (! signature || signature === 'td')
						return ['td'];

					// signature example: "td a i + td a span" => ["a i", "a span"]
					return String(signature)
						.split(' + ')
						.map(function (part) {
							part = String(part).trim();
							if (part.indexOf('td ') === 0)
								part = part.slice(3);
							return part.trim();
						})
						.filter(function (s) { return !!s; });
				}

				function hydrateFormInstanceFromDom($instance, dt)
				{
					const signature = $instance.data('selector') || 'td';
					const cssSelectors = signatureToCssSelectors(signature);

					const nodes = dt.column(window.columnIndexPreview, { page: 'current' }).nodes();
					if (! nodes || ! nodes.length)
						return;

					const collected = {
						fontStyle: [],
						fontSize: [],
						letterSpacing: [],
						fontWeight: [],
						textDecoration: [],
						textAlign: [],
						color: [],
						backgroundColor: [],
						width: [],
						maxWidth: [],
						minWidth: [],
					};

					$(nodes).each(function () {
						const td = this;

						cssSelectors.forEach(function (cssSel) {
							let $targets = cssSel === 'td' ? $(td) : $(td).find(cssSel);

							$targets.each(function () {
								const cs = getComputedStyle(this);
								collected.fontStyle.push(cs.fontStyle);
								collected.fontSize.push(parsePx(cs.fontSize));
								collected.letterSpacing.push(parsePx(cs.letterSpacing));
								collected.fontWeight.push(cs.fontWeight);
								collected.textDecoration.push(cs.textDecorationLine || cs.textDecoration);
								collected.textAlign.push(cs.textAlign);
								collected.color.push(rgbToHex(cs.color));
								collected.backgroundColor.push(rgbToHex(cs.backgroundColor));
								collected.width.push(parsePx(cs.width));
								collected.minWidth.push(parsePx(cs.width));
								collected.maxWidth.push(parsePx(cs.width));
							});
						});
					});

					// Normalize some computed styles to match UI button values
					collected.textAlign = collected.textAlign.map(function (v) {
						if (! v) return v;
						v = String(v).toLowerCase();
						if (v === 'start') return 'left';
						if (v === 'end') return 'right';
						return v;
					});

					collected.textDecoration = collected.textDecoration.map(function (v) {
						if (! v) return v;
						v = String(v).toLowerCase();
						// computed can be "none" or "underline" or "line-through" or contain multiple tokens
						if (v.indexOf('underline') !== -1) return 'underline';
						if (v.indexOf('line-through') !== -1) return 'line-through';
						return 'none';
					});

					collected.fontStyle = collected.fontStyle.map(function (v) {
						if (! v) return v;
						v = String(v).toLowerCase();
						return (v === 'italic' || v === 'oblique') ? 'italic' : 'normal';
					});

					// Apply MOST COMMON values to inputs
					$instance.find('.ib-style').each(function () {
						const style = this.dataset.style;
						if (! style || ! collected[style])
							return;

						const value = mostCommon(collected[style]);
						if (value === null || value === undefined)
							return;

						$(this).val(value);
					});

					// Hydrate button groups (e.g. textAlign)
					$instance.find('.ib-style-buttons').each(function () {
						const style = $(this).data('style');
						if (! style || ! collected[style])
							return;

						const value = mostCommon(collected[style]);
						if (value === null || value === undefined)
							return;

						__ibSetActiveStyleButton($(this), value);
					});
				}

				function applyDraftToColumn(dt)
				{
					if (! dt)
						return;

					const nodes = dt.column(window.columnIndexPreview, { page: 'current' }).nodes();
					if (! nodes || ! nodes.length)
						return;

					const draftsBySelector = window.__ibColumnStyleDraftBySelector || {};
					const selectorKeys = Object.keys(draftsBySelector);
					if (! selectorKeys.length)
						return;

					$(nodes).each(function () {
						const td = this;

						selectorKeys.forEach(function (signature) {
							const draft = draftsBySelector[signature] || {};
							const styleKeys = Object.keys(draft);
							if (! styleKeys.length)
								return;

							const cssSelectors = signatureToCssSelectors(signature);

							cssSelectors.forEach(function (cssSel) {
								let $targets;

								if (cssSel === 'td')
									$targets = $(td);
								else
									$targets = $(td).find(cssSel);

								$targets.each(function () {
									const el = this;
									styleKeys.forEach(function (styleKey) {
										const raw = draft[styleKey];
										const v = normalizeCssValue(styleKey, raw);
										el.style[styleKey] = v;


										// When setting width, also lock min/max to the same value
										if (styleKey === 'width' || styleKey === 'minWidth' || styleKey === 'maxWidth')
										{
											// Use CSS property names (kebab-case) for setProperty
											el.style.setProperty('width', v, 'important');
											el.style.setProperty('min-width', v, 'important');
											el.style.setProperty('max-width', v, 'important');
										}
									});
								});
							});
						});
					});

					if (dt.columns && dt.columns.adjust)
						dt.columns.adjust();
				}

				function applyStyle(style, value, dt, selectorSignature)
				{
					selectorSignature = selectorSignature || 'td';

					window.__ibColumnStyleDraftBySelector = window.__ibColumnStyleDraftBySelector || {};
					window.__ibColumnStyleDraftBySelector[selectorSignature] = window.__ibColumnStyleDraftBySelector[selectorSignature] || {};
					window.__ibColumnStyleDraftBySelector[selectorSignature][style] = value;

					if (style === 'width'|| style === 'minWidth'||style === 'maxWidth')
					{
						console.log('Setting width/minWidth/maxWidth together for style:', style, 'value:', value);
						window.__ibColumnStyleDraftBySelector[selectorSignature]['minWidth'] = value;
						window.__ibColumnStyleDraftBySelector[selectorSignature]['maxWidth'] = value;
					}

					// Apply to visible nodes
					applyDraftToColumn(dt);

					// Debug output: print ALL directives currently set for this selector
					try
					{
						const allRaw = window.__ibColumnStyleDraftBySelector[selectorSignature] || {};
						const allNormalized = {};
						Object.keys(allRaw).forEach(function (k) {
							allNormalized[k] = normalizeCssValue(k, allRaw[k]);
						});

						const json = {
							columnIndex: window.columnIndexPreview,
							columnName: window.__ibColumnNamePreview,
							selector: selectorSignature,
							directives: allNormalized
						};
						console.log('[ib-colvis-style]', JSON.stringify(json));
					}
					catch (e)
					{
						console.log('[ib-colvis-style]', {
							columnIndex: window.columnIndexPreview,
							columnName: window.__ibColumnNamePreview,
							selector: selectorSignature,
							directives: window.__ibColumnStyleDraftBySelector[selectorSignature] || {}
						});
					}
				}

				function appendColvisSettingsFormInstance($container, title, selectorSignature)
				{
					const $tpl = $('#colvis-settings-form-template');
					if (! $tpl.length)
						return null;

					const $instance = $tpl.clone(false, false)
						.removeAttr('id')
						.addClass('ib-colvis-settings-instance')
						// .css({ flexBasis: '100%', width: '100%' })
						.show();

					$instance.attr('data-selector', selectorSignature || 'td');
					// $instance.find('.uk-heading-divider').text(title);

					$container.append($instance);
					return $instance;
				}

				// Select column with gear
				$('body').on('click', 'a.ib-colvis-gear', function (e) {
					e.preventDefault();
					e.stopPropagation();

					// remove any existing instance in this toggle list
					$(this).closest('ul.toggle-vis-container').find('.ib-colvis-settings-instance').remove();
					$(this).closest('ul.toggle-vis-container').find('.ib-colvis-accordion').remove();

					// Clone the hidden template under the clicked <li>
					const $li = $(this).closest('li');

					// Accordion container for selector forms
					const $accordion = $('<ul class="uk-accordion ib-colvis-accordion uk-width-1-1" uk-accordion></ul>');
					$li.append($accordion);

					function addAccordionItem(selectorSignature, title)
					{
						const $item = $('<li></li>');
						const $itemTitle = $('<a class="uk-accordion-title" href="#"></a>').text(title);
						const $itemContent = $('<div class="uk-accordion-content"></div>');

						$item.append($itemTitle).append($itemContent);
						$accordion.append($item);

						return $itemContent;
					}

					const toggle = this.parentElement.querySelector('a.toggle-vis');
					const col = toggle ? toggle.dataset.column : null;
					if (toggle && toggle.dataset && toggle.dataset.name)
						window.__ibColumnNamePreview = toggle.dataset.name;
					if (col !== null && col !== undefined)
						window.columnIndexPreview = parseInt(col, 10);

					const dt = getDtFromToggleContainer(this);
					if (! dt)
						return;

					// reset draft map for this click
					window.__ibColumnStyleDraftBySelector = {};

					// reset any previous preview styles on this column
					clearPreviewFromColumn(dt, window.columnIndexPreview);

					const elements = ibInspectVisibleColumnStructures(dt, window.columnIndexPreview) || [];

					const $mainContent = addAccordionItem('td', 'td');
					const $mainInstance = appendColvisSettingsFormInstance($mainContent, 'Cella principale', 'td');
					hydrateFormInstanceFromDom($mainInstance, dt);

					//foreach element appendColvisSettingsFormInstance with title element
					elements.forEach(function(element) {
						if (! element)
							return;

						// Skip td: already added as main
						if (element === 'td')
							return;

						const $content = addAccordionItem(element, element);
						const $inst = appendColvisSettingsFormInstance($content, 'Struttura: ' + element, element);
						hydrateFormInstanceFromDom($inst, dt);
					});

				});

				// Helper for setting active button in a group (button group styles)
				function __ibSetActiveStyleButton($group, value)
				{
					if (! $group || ! $group.length)
						return;

					$group.find('.ib-style-button').each(function () {
						const isActive = String($(this).data('value')) === String(value);
						$(this).toggleClass('uk-button-primary', isActive);
						$(this).toggleClass('uk-button-default', ! isActive);
					});
				}

				// Helper for getting DataTable instance from an element inside settings UI
				function __ibGetDtFromInstance(el)
				{
					const tableId = $(el).closest('ul.toggle-vis-container').data('tableid');
					if (! tableId)
						return null;

					return $('#' + tableId).DataTable();
				}

				// Bind style inputs (live preview). Works globally since the form lives in DOM.
				// Legacy inputs/selects (text, number, select, color...)
				$('body').on('input change', '.colvis-settings-form .ib-style', function () {
					const style = this.dataset.style;
					if (! style)
						return;

					const $instance = $(this).closest('.ib-colvis-settings-instance');
					const selectorSignature = $instance.data('selector') || 'td';

					const dt = __ibGetDtFromInstance(this);
					if (! dt)
						return;

					applyStyle(style, this.value, dt, selectorSignature);
				});

				// New button-groups (e.g. text-align)
				$('body').on('click', '.colvis-settings-form .ib-style-buttons .ib-style-button', function (e) {
					e.preventDefault();
					e.stopPropagation();

					const $btn = $(this);
					const $group = $btn.closest('.ib-style-buttons');
					const style = $group.data('style');

					if (! style)
						return;

					const value = String($btn.data('value'));

					const $instance = $btn.closest('.ib-colvis-settings-instance');
					const selectorSignature = $instance.data('selector') || 'td';

					const dt = __ibGetDtFromInstance(this);
					if (! dt)
						return;

					__ibSetActiveStyleButton($group, value);

					applyStyle(style, value, dt, selectorSignature);
				});
			}

			$('.filterfunctions .hidecolumn').click(function (e)
			{
				e.stopPropagation();

				let th = $(this).parents('th');
				let columnName = th.data('name');

				var dt = $('#' + $(this).parents('table').data('realid')).DataTable();

				return dt.manageColumnVisibility(columnName, false);
			});

		});
	} else {
		// Riprova dopo un attimo
		setTimeout(registerIlBronzaDatatablesColumnVisibility, 100);
	}
})();