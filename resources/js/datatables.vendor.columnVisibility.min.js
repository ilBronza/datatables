(function registerIlBronzaDatatablesColumnVisibility() {
	if ($.fn.dataTable && $.fn.dataTable.Api) {

		function toCamelCase(str)
		{
			if (!str || typeof str !== 'string')
				return str;

			return str
				.replace(/[-_.]+(.)?/g, (_, chr) => chr ? chr.toUpperCase() : '')
				.replace(/^(.)/, m => m.toLowerCase());
		}

		function ibDescribeNodeChain(node) {
			if (!node || !node.tagName) return '';

			const tag = node.tagName.toLowerCase();
			const children = Array.from(node.children || []).filter(c => c && c.tagName);

			if (!children.length) return tag;

			// a (span + i) -> "a span + i"
			const described = children.map(ibDescribeNodeChain).filter(Boolean);
			return tag + ' ' + described.join(' + ');
		}

		function ibGetTdStructureSignature(td) {
			if (!td) return 'td';

			const children = Array.from(td.children || []).filter(c => c && c.tagName);
			if (!children.length) return 'td';

			// root branches prefixed with "td " like the examples:
			// td has <a><i/></a> and <a><span/></a> -> "td a i + td a span"
			return children
				.map(c => {
					const chain = ibDescribeNodeChain(c);
					return chain ? ('td ' + chain) : 'td';
				})
				.filter(Boolean)
				.join(' + ');
		}


		// ---- PATCH: CSRF token helper ----
		function __ibGetCsrfToken()
		{
			return $('meta[name="csrf-token"]').attr('content') || $('input[name="_token"]').first().val() || '';
		}

		// ---- PATCH: Submit JSON via AJAX POST ----
		function __ibSubmitJsonToUrl(url, payload)
		{
			if (! url)
				return;

			const token = __ibGetCsrfToken();

			return $.ajax({
				url: url,
				type: 'POST',
				dataType: 'json',
				headers: token ? { 'X-CSRF-TOKEN': token } : {},
				data: {
					settings_json: JSON.stringify(payload),
					columnIndex: payload ? payload.columnIndex : null,
					columnName: payload ? payload.columnName : null
				}
			})
			.done(function (response) {
				if (response && response.success)
				{
					if (typeof window.addSuccessNotification === 'function')
						window.addSuccessNotification('Settings saved');
					else
						console.log('[ib-colvis-save] saved', response);
				}
				else
				{
					if (typeof window.addDangerNotification === 'function')
						window.addDangerNotification('Could not save settings');
					else
						console.log('[ib-colvis-save] save failed', response);
				}
			})
			.fail(function (xhr) {
				if (typeof window.addDangerNotification === 'function')
					window.addDangerNotification('Could not save settings');
				else
					console.log('[ib-colvis-save] ajax error', xhr);
			});
		}

		function __ibNormalizeCssValue(style, value)
		{
			if (value === undefined || value === null)
				return value;

			const isNumeric = (typeof value === 'number') || (typeof value === 'string' && value !== '' && !isNaN(value));

			if (style === 'font-size' || style === 'letter-spacing')
				return isNumeric ? (value + 'px') : value;

			if (style === 'width' || style === 'min-width' || style === 'max-width')
			{
				if (value === '' || value === 'auto')
					return value;
				return isNumeric ? (value + 'px') : value;
			}

			if (style === 'text-overflow-mode')
				return String(value);

			return value;
		}

		// ---- PATCH: Build consolidated JSON payload ----
		function __ibBuildColumnSettingsPayload()
		{
			const drafts = window.__ibColumnStyleDraftBySelector || {};
			const selectors = Object.keys(drafts);

			const directivesBySelector = {};
			selectors.forEach(function (sel) {
				const raw = drafts[sel] || {};
				const normalized = {};

				Object.keys(raw).forEach(function (k) {
					if (k === '__tooltip')
					{
						normalized[k] = !! raw[k];
						return;
					}
					normalized[k] = __ibNormalizeCssValue(k, raw[k]);
				});

				directivesBySelector[sel] = normalized;
			});

			return {
				columnIndex: window.columnIndexPreview,
				columnName: window.__ibColumnNamePreview,
				selectors: directivesBySelector
			};
		}

		// ---- PATCH: Bind Save button in any settings form instance ----
				// Save: submit consolidated JSON payload to controller URL from data-settings-url
				$(document).on('click', '.ib-colvis-save', function (e) {
					e.preventDefault();
					e.stopPropagation();

					// Prefer URL on the settings form wrapper
					const $formWrapper = $(this).closest('.colvis-settings-form');
					let url = $formWrapper.data('settings-url') || $formWrapper.attr('data-settings-url');

					// Fallback: support legacy container attribute if present
					if (! url)
					{
						const $colVisContainer = $(this).closest('.ib-colvis-container');
						url = $colVisContainer.data('settings-store-url') || $colVisContainer.attr('data-settings-store-url');
					}

					if (! url)
					{
						console.log('[ib-colvis-save] missing data-settings-url');
						return;
					}

					const payload = __ibBuildColumnSettingsPayload();
					__ibSubmitJsonToUrl(url, payload);
				});

		function ibCollectDistinctTagClassSignatures(td)
		{
			const out = new Set();
			if (! td)
				return out;

			// Collect elements + compute per-tag intersection of classes ("base" classes)
			// Base classes are removed ONLY if there is real variation (more than one distinct class-combination)
			const elements = Array.from(td.querySelectorAll('*'));
			const byTagBase = {};   // tag -> Set of classes present on ALL elements of that tag
			const byTagCombos = {}; // tag -> Set of distinct class-combinations (serialized)
			const collected = [];   // [{tag, classes:Set}]

			elements.forEach(function (el) {
				if (! el || ! el.tagName)
					return;

				const tag = el.tagName.toLowerCase();
				if (! el.classList || ! el.classList.length)
					return;

				const clsSet = new Set();
				el.classList.forEach(function (c) {
					if (c)
						clsSet.add(c);
				});

				if (! clsSet.size)
					return;

				collected.push({ tag: tag, classes: clsSet });

				// Track distinct class-combinations for this tag
				if (! byTagCombos[tag])
					byTagCombos[tag] = new Set();

				const comboKey = Array.from(clsSet).sort().join('|');
				byTagCombos[tag].add(comboKey);

				// Build intersection with existing base set
				if (! byTagBase[tag])
				{
					byTagBase[tag] = new Set(clsSet);
				}
				else
				{
					const next = new Set();
					byTagBase[tag].forEach(function (c) {
						if (clsSet.has(c))
							next.add(c);
					});
					byTagBase[tag] = next;
				}
			});

			// Build signatures, excluding base classes only when there is real variation for that tag
			collected.forEach(function (row) {
				const tag = row.tag;
				const comboCount = (byTagCombos[tag] && byTagCombos[tag].size) ? byTagCombos[tag].size : 0;
				const base = comboCount > 1 ? (byTagBase[tag] || new Set()) : new Set();

				row.classes.forEach(function (cls) {
					if (! cls)
						return;
					if (String(cls).indexOf(' ') !== -1)
						return;

					// Skip base classes that are always present for this tag (e.g. fa-solid) ONLY if there is variation
					if (base.has(cls))
						return;

					out.add('td ' + tag + '.' + cls);
				});
			});

			return out;
		}

		function ibCollectDistinctTagClassSignaturesFromTds(tds)
		{
			const out = new Set();
			if (! tds || ! tds.length)
				return out;

			// Collect over ALL td nodes (column scope)
			const byTagBase = {};   // tag -> Set of classes present on ALL elements of that tag (intersection)
			const byTagCombos = {}; // tag -> Set of distinct class-combinations (serialized)
			const collected = [];   // [{tag, classes:Set}]

			Array.from(tds).forEach(function (td) {
				if (! td)
					return;

				const elements = Array.from(td.querySelectorAll('*'));
				elements.forEach(function (el) {
					if (! el || ! el.tagName)
						return;

					const tag = el.tagName.toLowerCase();
					if (! el.classList || ! el.classList.length)
						return;

					const clsSet = new Set();
					el.classList.forEach(function (c) {
						if (c)
							clsSet.add(c);
					});

					if (! clsSet.size)
						return;

					collected.push({ tag: tag, classes: clsSet });

					// combos
					if (! byTagCombos[tag])
						byTagCombos[tag] = new Set();
					const comboKey = Array.from(clsSet).sort().join('|');
					byTagCombos[tag].add(comboKey);

					// intersection
					if (! byTagBase[tag])
						byTagBase[tag] = new Set(clsSet);
					else
					{
						const next = new Set();
						byTagBase[tag].forEach(function (c) {
							if (clsSet.has(c))
								next.add(c);
						});
						byTagBase[tag] = next;
					}
				});
			});

			// Emit signatures: exclude base classes only when there is variation for that tag
			collected.forEach(function (row) {
				const tag = row.tag;
				const comboCount = (byTagCombos[tag] && byTagCombos[tag].size) ? byTagCombos[tag].size : 0;
				const base = comboCount > 1 ? (byTagBase[tag] || new Set()) : new Set();

				row.classes.forEach(function (cls) {
					if (! cls)
						return;
					if (String(cls).indexOf(' ') !== -1)
						return;
					if (base.has(cls))
						return;

					out.add('td ' + tag + '.' + cls);
				});
			});

			return out;
		}

		function ibMergeStructuresAndClassSelectors(structures, classSelectors)
		{
			const set = new Set();
			(structures || []).forEach(function (s) { if (s) set.add(s); });
			(classSelectors || []).forEach(function (s) { if (s) set.add(s); });
			return Array.from(set).sort(function (a, b) { return a.localeCompare(b); });
		}

		function ibInspectVisibleColumnStructures(dt, columnIndex) {
			if (!dt || typeof dt.column !== 'function') return;

			const nodes = dt.column(columnIndex, { page: 'current' }).nodes();
			const set = new Set();

			const classSet = new Set();

			for (let i = 0; i < nodes.length; i++) {
				const td = nodes[i];
				set.add(ibGetTdStructureSignature(td));
			}

			const tagClass = ibCollectDistinctTagClassSignaturesFromTds(nodes);
			tagClass.forEach(function (sig) { classSet.add(sig); });

			const structures = Array.from(set);
			const classSelectors = Array.from(classSet);
			const merged = ibMergeStructuresAndClassSelectors(structures, classSelectors);

			console.log(merged);
			return merged;
		}

		function clearPreviewFromColumn(dt, columnIndex)
		{
			if (! dt)
				return;

			const nodes = dt.column(columnIndex, { page: 'current' }).nodes();
			if (! nodes || ! nodes.length)
				return;

			const clearKeys = [
				'font-style',
				'font-size',
				'letter-spacing',
				'font-weight',
				'text-decoration',
				'text-align',
				'color',
				'background-color',
				'width',
				'min-width',
				'max-width',
				'white-space',
				'overflow',
				'text-overflow'
			];

			$(nodes).each(function () {
				const td = this;

				// clear TD
				clearKeys.forEach(function (k) {
					td.style.removeProperty(k);
				});

				// clear descendants
				$(td).find('*').each(function () {
					const el = this;
					clearKeys.forEach(function (k) {
						el.style.removeProperty(k);
					});
				});

				td.removeAttribute('title');
				td.removeAttribute('uk-tooltip');
			});
		}

		$.fn.dataTable.Api.register('manageColumnVisibility()', function (columnName, visibility)
		{
			let dt = this;

			let table = this.getTableElement();
			let tableColumnDisplayRoute = table.data('columndisplayroute');

			let a = $('#togglefields' + table.attr('id')).find('[data-name="' + columnName + '"]');

			let action;

			if(visibility)
				action = 'showColumn';
			else
				action = 'hideColumn';

			var column = dt.column(a.data('column'));

			column.visible( visibility );

			if(visibility)
				$(a).data('visibility', 1).addClass('uk-text-bold');
			else
				$(a).data('visibility', 0).removeClass('uk-text-bold');

			$.ajax({
				url: tableColumnDisplayRoute,
				dataType: 'json',
				type: 'POST',
				data: {
					columnName: columnName,
					action: action
				},
				success: function(response)
				{
					if(! response.success == true)
						return this.error(response);

					if(visibility)
						window.addSuccessNotification('Colonna "' + a.text() + '" mostrata con successo');
					else
						window.addWarningNotification('Colonna "' + a.text() + '" nascosta con successo');

				},
				error: function (response)
				{
					window.addDangerNotification('Impossibile modificare la visualizzazione della colonna');
				}
			});
		});



		$(document).ready(function($)
		{
			// Init Select2 font-family preview (safe, idempotent)
			function __ibInitFontFamilySelect(context)
			{
				$(context).find('select.font-family-select').each(function ()
				{
					const $select = $(this);

					// prevent double init
					if ($select.data('select2'))
						return;

					$select.select2({
						width: '100%',
						templateResult: function (state) {
							if (!state.id) return state.text;
							return $('<span>').css('font-family', state.id).text(state.text);
						},
						templateSelection: function (state) {
							if (!state.id) return state.text;
							return $('<span>').css('font-family', state.id).text(state.text);
						},
						escapeMarkup: function (m) { return m; }
					});
				});
			}

			// first init
			__ibInitFontFamilySelect(document);

			// re-init when column settings accordion is created
			$('body').on('shown.uk.accordion', '.ib-colvis-accordion', function () {
				__ibInitFontFamilySelect(this);
			});
			$('a.toggle-vis').on('click', function (e)
			{
				var that = this;
				e.preventDefault();

				var dt = $('#' + $(that).parents('ul.toggle-vis-container').data('tableid')).DataTable();

				let columnName = $(that).data('name');
				let currentVisibility = $(that).data('visibility');

				return dt.manageColumnVisibility(columnName, ! currentVisibility);
			});

			// Column settings preview (styles) - selects column via gear and applies styles to real TDs
			if (! window.__ibColumnSettingsPreviewBound)
			{
				window.__ibColumnSettingsPreviewBound = true;

				window.columnIndexPreview = window.columnIndexPreview ?? 6;
				window.__ibColumnStyleDraftBySelector = window.__ibColumnStyleDraftBySelector || {};
				window.__ibColumnStyleDraft = window.__ibColumnStyleDraft || {}; // legacy (kept, but unused)
				window.__ibColumnNamePreview = null;

				function normalizeCssValue(style, value)
				{
					return __ibNormalizeCssValue(style, value);
				}

				function getDtFromToggleContainer(el)
				{
					const tableId = $(el).parents('ul.toggle-vis-container').data('tableid');
					if (! tableId)
						return null;

					return $('#' + tableId).DataTable();
				}

				function parsePx(value)
				{
					if (! value || value === 'normal')
						return 0;
					if (typeof value === 'string' && value.endsWith('px'))
						return parseFloat(value.replace('px', ''));
					return parseFloat(value) || 0;
				}

				function rgbToHex(rgb)
				{
					if (! rgb)
						return '';
					const m = rgb.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
					if (! m)
						return '';
					return '#'
						+ ('0' + parseInt(m[1], 10).toString(16)).slice(-2)
						+ ('0' + parseInt(m[2], 10).toString(16)).slice(-2)
						+ ('0' + parseInt(m[3], 10).toString(16)).slice(-2);
				}

				function mostCommon(values)
				{
					const map = {};
					let max = 0;
					let res = null;
					values.forEach(function (v) {
						if (v === undefined || v === null)
							return;
						map[v] = (map[v] || 0) + 1;
						if (map[v] > max)
						{
							max = map[v];
							res = v;
						}
					});
					return res;
				}

				function signatureToCssSelectors(signature)
				{
					if (! signature || signature === 'td')
						return ['td'];

					// signature example: "td a i + td a span" => ["a i", "a span"]
					return String(signature)
						.split(' + ')
						.map(function (part) {
							part = String(part).trim();
							if (part.indexOf('td ') === 0)
								part = part.slice(3);
							return part.trim();
						})
						.filter(function (s) { return !!s; });
				}

				function hydrateFormInstanceFromDom($instance, dt)
				{
// ---- NEW: hydrate from persisted draft (by tableId + columnName + selector) ----
const tableId = dt && dt.table && dt.table().node ? dt.table().node().id : null;
const columnKey = window.__ibColumnNamePreview;
const selectorSignature = $instance.data('selector') || 'td';

const persisted =
    tableId &&
    window.__ibColumnStyleDraftByTable &&
    window.__ibColumnStyleDraftByTable[tableId] &&
    window.__ibColumnStyleDraftByTable[tableId][columnKey] &&
    window.__ibColumnStyleDraftByTable[tableId][columnKey].selectors &&
    window.__ibColumnStyleDraftByTable[tableId][columnKey].selectors[selectorSignature]
        ? window.__ibColumnStyleDraftByTable[tableId][columnKey].selectors[selectorSignature]
        : null;

if (persisted)
{
    // inputs
    $instance.find('.ib-style').each(function () {
        const style = this.dataset.style;
        if (style && Object.prototype.hasOwnProperty.call(persisted, style))
            $(this).val(persisted[style]);
    });

    // button groups
    $instance.find('.ib-style-buttons').each(function () {
        const style = $(this).data('style');

        if (style === 'text-overflow-mode' && persisted.__tooltip)
        {
            __ibSetActiveStyleButton($(this), 'tooltip');
            return;
        }

        if (style && Object.prototype.hasOwnProperty.call(persisted, style))
            __ibSetActiveStyleButton($(this), persisted[style]);
    });

    return; // IMPORTANT: skip DOM-based hydration
}
					const signature = $instance.data('selector') || 'td';
					const cssSelectors = signatureToCssSelectors(signature);

					const nodes = dt.column(window.columnIndexPreview, { page: 'current' }).nodes();
					if (! nodes || ! nodes.length)
						return;

					const collected = {
						'font-style': [],
						'font-size': [],
						'letter-spacing': [],
						'font-weight': [],
						'text-decoration': [],
						'text-align': [],
						'color': [],
						'background-color': [],
						'width': [],
						'max-width': [],
						'min-width': [],
						'text-overflow-mode': [],
					};

					$(nodes).each(function () {
						const td = this;

						cssSelectors.forEach(function (cssSel) {
							let $targets = cssSel === 'td' ? $(td) : $(td).find(cssSel);

							$targets.each(function () {
								const cs = getComputedStyle(this);
								collected['font-style'].push(cs.fontStyle);
								collected['font-size'].push(parsePx(cs.fontSize));
								collected['letter-spacing'].push(parsePx(cs.letterSpacing));
								collected['font-weight'].push(cs.fontWeight);
								collected['text-decoration'].push(cs.textDecorationLine || cs.textDecoration);
								collected['text-align'].push(cs.textAlign);
								collected['color'].push(rgbToHex(cs.color));
								collected['background-color'].push(rgbToHex(cs.backgroundColor));
								collected['width'].push(parsePx(cs.width));
								collected['min-width'].push(parsePx(cs.width));
								collected['max-width'].push(parsePx(cs.width));
								collected['text-overflow-mode'].push({
									whiteSpace: cs.whiteSpace,
									overflow: cs.overflow,
									textOverflow: cs.textOverflow
								});
							});
						});
					});

					// Normalize some computed styles to match UI button values
					collected['text-align'] = collected['text-align'].map(function (v) {
						if (! v) return v;
						v = String(v).toLowerCase();
						if (v === 'start') return 'left';
						if (v === 'end') return 'right';
						return v;
					});

					collected['text-decoration'] = collected['text-decoration'].map(function (v) {
						if (! v) return v;
						v = String(v).toLowerCase();
						// computed can be "none" or "underline" or "line-through" or contain multiple tokens
						if (v.indexOf('underline') !== -1) return 'underline';
						if (v.indexOf('line-through') !== -1) return 'line-through';
						return 'none';
					});

					collected['font-style'] = collected['font-style'].map(function (v) {
						if (! v) return v;
						v = String(v).toLowerCase();
						return (v === 'italic' || v === 'oblique') ? 'italic' : 'normal';
					});

					// Normalize overflow mode from computed styles
					collected['text-overflow-mode'] = collected['text-overflow-mode'].map(function (o) {
						if (! o) return o;

						const ws = String(o.whiteSpace || '').toLowerCase();
						const ov = String(o.overflow || '').toLowerCase();
						const to = String(o.textOverflow || '').toLowerCase();

						// wrap: normal white-space
						if (ws !== 'nowrap')
							return 'wrap';

						// nowrap + ellipsis
						if (to === 'ellipsis')
							return 'ellipsis';

						// nowrap + hidden (clip)
						if (ov === 'hidden' || ov === 'clip')
							return 'clip';

						// fallback
						return 'clip';
					});

					// Apply MOST COMMON values to inputs
					$instance.find('.ib-style').each(function () {
						const style = this.dataset.style;
						if (! style || ! collected[style])
							return;

						const value = mostCommon(collected[style]);
						if (value === null || value === undefined)
							return;

						$(this).val(value);
					});

					// Hydrate button groups (e.g. textAlign)
					$instance.find('.ib-style-buttons').each(function () {
						const style = $(this).data('style');
						if (! style || ! collected[style])
							return;

						let value = mostCommon(collected[style]);
						if (value === null || value === undefined)
							return;

						// If tooltip mode is enabled in the draft, show the "tooltip" button as active
						if (style === 'text-overflow-mode')
						{
							const signature = $instance.data('selector') || 'td';
							const draft = (window.__ibColumnStyleDraftBySelector && window.__ibColumnStyleDraftBySelector[signature]) ? window.__ibColumnStyleDraftBySelector[signature] : {};
							if (draft && draft.__tooltip)
								value = 'tooltip';
						}

						__ibSetActiveStyleButton($(this), value);
					});
				}

				function applyDraftToColumn(dt)
				{
					if (! dt)
						return;

					const nodes = dt.column(window.columnIndexPreview, { page: 'current' }).nodes();
					if (! nodes || ! nodes.length)
						return;

					const draftsBySelector = window.__ibColumnStyleDraftBySelector || {};
					const selectorKeys = Object.keys(draftsBySelector);
					if (! selectorKeys.length)
						return;

					$(nodes).each(function () {
						const td = this;

						selectorKeys.forEach(function (signature) {
							const draft = draftsBySelector[signature] || {};
							const styleKeys = Object.keys(draft);
							if (! styleKeys.length)
								return;

							const cssSelectors = signatureToCssSelectors(signature);

							cssSelectors.forEach(function (cssSel) {
								let $targets;

								if (cssSel === 'td')
									$targets = $(td);
								else
									$targets = $(td).find(cssSel);

								$targets.each(function () {
									const el = this;
									styleKeys.forEach(function (styleKey) {
										const raw = draft[styleKey];
										const v = normalizeCssValue(styleKey, raw);

									// Special pseudo-style: text-overflow-mode
									if (styleKey === 'text-overflow-mode')
									{
										// Reset first
										el.style.removeProperty('white-space');
										el.style.removeProperty('overflow');
										el.style.removeProperty('text-overflow');

										if (v === 'wrap')
										{
											el.style.setProperty('white-space', 'normal', 'important');
											el.style.setProperty('overflow', 'visible', 'important');
											el.style.setProperty('text-overflow', 'clip', 'important');
										}
										else if (v === 'ellipsis')
										{
											el.style.setProperty('white-space', 'nowrap', 'important');
											el.style.setProperty('overflow', 'hidden', 'important');
											el.style.setProperty('text-overflow', 'ellipsis', 'important');
										}
										else // clip / default
										{
											el.style.setProperty('white-space', 'nowrap', 'important');
											el.style.setProperty('overflow', 'hidden', 'important');
											el.style.setProperty('text-overflow', 'clip', 'important');
										}

										return;
									}

									el.style.setProperty(styleKey, v, 'important');

									// When setting width, also lock min/max to the same value
									if (styleKey === 'width' || styleKey === 'min-width' || styleKey === 'max-width')
									{
										// Use CSS property names (kebab-case) for setProperty
										el.style.setProperty('width', v, 'important');
										el.style.setProperty('min-width', v, 'important');
										el.style.setProperty('max-width', v, 'important');
									}
									});
								});
							});

							// After styles, set/remove tooltip attributes on the TD
							const tooltipEnabled = !! (draft && draft.__tooltip);

							if (tooltipEnabled)
							{
								const t = String(td.innerText || '').trim();
								if (t)
									td.setAttribute('title', t);
								td.setAttribute('uk-tooltip', '');
							}
							else
							{
								td.removeAttribute('title');
								td.removeAttribute('uk-tooltip');
							}
						});
					});

					if (dt.columns && dt.columns.adjust)
						dt.columns.adjust();
				}

				function applyStyle(style, value, dt, selectorSignature)
				{
					selectorSignature = selectorSignature || 'td';

					// textOverflowMode supports a UI-only value "tooltip" (ellipsis + title tooltip)
					if (style === 'text-overflow-mode')
					{
						const isTooltip = String(value) === 'tooltip';
						// store a flag and apply ellipsis styles for visual clipping
						window.__ibColumnStyleDraftBySelector = window.__ibColumnStyleDraftBySelector || {};
						window.__ibColumnStyleDraftBySelector[selectorSignature] = window.__ibColumnStyleDraftBySelector[selectorSignature] || {};
						window.__ibColumnStyleDraftBySelector[selectorSignature].__tooltip = isTooltip;

						if (isTooltip)
							value = 'ellipsis';
					}

					window.__ibColumnStyleDraftBySelector = window.__ibColumnStyleDraftBySelector || {};
					window.__ibColumnStyleDraftBySelector[selectorSignature] = window.__ibColumnStyleDraftBySelector[selectorSignature] || {};
					window.__ibColumnStyleDraftBySelector[selectorSignature][style] = value;

					if (style === 'width'|| style === 'min-width'||style === 'max-width')
					{
						window.__ibColumnStyleDraftBySelector[selectorSignature]['min-width'] = value;
						window.__ibColumnStyleDraftBySelector[selectorSignature]['max-width'] = value;
					}

					// Apply to visible nodes
					applyDraftToColumn(dt);

// Debug output: print ALL directives currently set for ALL selectors (td + sibling structures)
					try
					{
						const drafts = window.__ibColumnStyleDraftBySelector || {};
						const selectors = Object.keys(drafts);

						const directivesBySelector = {};
						selectors.forEach(function (sel) {
							const raw = drafts[sel] || {};
							const normalized = {};

							Object.keys(raw).forEach(function (k) {
								// keep private flags as-is
								if (k === '__tooltip')
								{
									normalized[k] = !! raw[k];
									return;
								}

								normalized[k] = normalizeCssValue(k, raw[k]);
							});

							directivesBySelector[sel] = normalized;
						});

						const json = {
							columnIndex: window.columnIndexPreview,
							columnName: window.__ibColumnNamePreview,
							selectors: directivesBySelector
						};

						console.log('[ib-colvis-style]', JSON.stringify(json));
					}
					catch (e)
					{
						console.log('[ib-colvis-style]', {
							columnIndex: window.columnIndexPreview,
							columnName: window.__ibColumnNamePreview,
							selectors: window.__ibColumnStyleDraftBySelector || {}
						});
					}
				}

				function appendColvisSettingsFormInstance($container, title, selectorSignature)
				{
					const $tpl = $('#colvis-settings-form-template');
					if (! $tpl.length)
						return null;

					const $instance = $tpl.clone(false, false)
						.removeAttr('id')
						.addClass('ib-colvis-settings-instance')
						// .css({ flexBasis: '100%', width: '100%' })
						.show();

					$instance.attr('data-selector', selectorSignature || 'td');
					// $instance.find('.uk-heading-divider').text(title);

					$container.append($instance);
					return $instance;
				}

				// Select column with gear
				$('body').on('click', 'a.ib-colvis-gear', function (e) {
					e.preventDefault();
					e.stopPropagation();

					// remove any existing instance in this toggle list
					$(this).closest('ul.toggle-vis-container').find('.ib-colvis-settings-instance').remove();
					$(this).closest('ul.toggle-vis-container').find('.ib-colvis-accordion').remove();

					// Clone the hidden template under the clicked <li>
					const $li = $(this).closest('li');

					// Accordion container for selector forms
					const $accordion = $('<ul class="uk-accordion ib-colvis-accordion uk-width-1-1" uk-accordion></ul>');
					$li.append($accordion);

					function addAccordionItem(selectorSignature, title)
					{
						const $item = $('<li></li>');
						const $itemTitle = $('<a class="uk-accordion-title" href="#"></a>').text(title);
						const $itemContent = $('<div class="uk-accordion-content"></div>');

						$item.append($itemTitle).append($itemContent);
						$accordion.append($item);

						return $itemContent;
					}

					const toggle = this.parentElement.querySelector('a.toggle-vis');
					const col = toggle ? toggle.dataset.column : null;
					if (toggle && toggle.dataset && toggle.dataset.name)
						window.__ibColumnNamePreview = toCamelCase(toggle.dataset.name);
					if (col !== null && col !== undefined)
						window.columnIndexPreview = parseInt(col, 10);

					const dt = getDtFromToggleContainer(this);
					if (! dt)
						return;

					// init draft map for this click: clone persisted selectors if present
					(function () {
					    const tableId = $(this).closest('ul.toggle-vis-container').data('tableid');
					    const columnKey = window.__ibColumnNamePreview;

					    const persistedSelectors =
					        tableId &&
					        window.__ibColumnStyleDraftByTable &&
					        window.__ibColumnStyleDraftByTable[tableId] &&
					        window.__ibColumnStyleDraftByTable[tableId][columnKey] &&
					        window.__ibColumnStyleDraftByTable[tableId][columnKey].selectors
					            ? window.__ibColumnStyleDraftByTable[tableId][columnKey].selectors
					            : null;

					    // deep clone to avoid mutating persisted state
					    window.__ibColumnStyleDraftBySelector = persistedSelectors
					        ? JSON.parse(JSON.stringify(persistedSelectors))
					        : {};
					}).call(this);

					// reset any previous preview styles on this column
					clearPreviewFromColumn(dt, window.columnIndexPreview);

					const elements = ibInspectVisibleColumnStructures(dt, window.columnIndexPreview) || [];

					const $mainContent = addAccordionItem('td', 'td');
					const $mainInstance = appendColvisSettingsFormInstance($mainContent, 'Cella principale', 'td');
					hydrateFormInstanceFromDom($mainInstance, dt);

					//foreach element appendColvisSettingsFormInstance with title element
					elements.forEach(function(element) {
						if (! element)
							return;

						// Skip td: already added as main
						if (element === 'td')
							return;

						const $content = addAccordionItem(element, element);
						const $inst = appendColvisSettingsFormInstance($content, 'Struttura: ' + element, element);
						hydrateFormInstanceFromDom($inst, dt);
					});

				});

				// Helper for setting active button in a group (button group styles)
				function __ibSetActiveStyleButton($group, value)
				{
					if (! $group || ! $group.length)
						return;

					$group.find('.ib-style-button').each(function () {
						const isActive = String($(this).data('value')) === String(value);
						$(this).toggleClass('uk-button-primary', isActive);
						$(this).toggleClass('uk-button-default', ! isActive);
					});
				}

				// Helper for getting DataTable instance from an element inside settings UI
				function __ibGetDtFromInstance(el)
				{
					const tableId = $(el).closest('ul.toggle-vis-container').data('tableid');
					if (! tableId)
						return null;

					return $('#' + tableId).DataTable();
				}

				// Bind style inputs (live preview). Works globally since the form lives in DOM.
				// Legacy inputs/selects (text, number, select, color...)
				$('body').on('input change', '.colvis-settings-form .ib-style', function () {
					const style = this.dataset.style;
					if (! style)
						return;

					const $instance = $(this).closest('.ib-colvis-settings-instance');
					const selectorSignature = $instance.data('selector') || 'td';

					const dt = __ibGetDtFromInstance(this);
					if (! dt)
						return;

					applyStyle(style, this.value, dt, selectorSignature);
				});

				// New button-groups (e.g. text-align)
				$('body').on('click', '.colvis-settings-form .ib-style-buttons .ib-style-button', function (e) {
					e.preventDefault();
					e.stopPropagation();

					const $btn = $(this);
					const $group = $btn.closest('.ib-style-buttons');
					const style = $group.data('style');

					if (! style)
						return;

					const value = String($btn.data('value'));

					const $instance = $btn.closest('.ib-colvis-settings-instance');
					const selectorSignature = $instance.data('selector') || 'td';

					const dt = __ibGetDtFromInstance(this);
					if (! dt)
						return;

					__ibSetActiveStyleButton($group, value);

					applyStyle(style, value, dt, selectorSignature);
				});
			}

			$('.filterfunctions .hidecolumn').click(function (e)
			{
				e.stopPropagation();

				let th = $(this).parents('th');
				let columnName = th.data('name');

				var dt = $('#' + $(this).parents('table').data('realid')).DataTable();

				return dt.manageColumnVisibility(columnName, false);
			});

		});
	} else {
		// Riprova dopo un attimo
		setTimeout(registerIlBronzaDatatablesColumnVisibility, 100);
	}
})();